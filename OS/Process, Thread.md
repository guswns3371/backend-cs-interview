# Process, Thread

## 프로세스

`프로세스`는 실행중에 있는 프로그램이다.

> 프로세스의 Context
> 

`프로세스의 컨택스트`란 CPU 스케쥴링이 일어나면 프로세스의 이전 상태를 재현해야하는데 필요한 정보이다.

1. `CPU 수행 상태를 나타내는 하드웨어 문맥` : PC 값, 레지스터 정보
    - PC값 : 프로세스가 명령어를 어디까지 수행했는지 나타내는 포인터 정보
2. `프로세스의 주소 공간` : code, data, stack
3. `프로세스 관련 커널 자료구조` : PCB, Kernel Stack
    - PCB : 운영체제가 프로세스를 관리하기 위해 사용하는 커널의 자료구조. 커널의 데이터 영역에 프로세스 PCB를 저장한다
    - Kernel Stack : 프로세스가 시스템콜을 수행하면 PC가 커널의 code영역을 가리키면서 명령어를 수행한다. 이때 함수 호출이 일어나면 관련 정보가 Kernel Stack에 쌓인다.

위와 같은 정보는 각 프로세스마다 독립적으로 존재한다.

> 프로세스 상태
> 

![Untitled](Process,%20T%20b6901/Untitled.png)

- `Running` : CPU 점유권을 가지고 명령을 수행중인 상태
- `Ready` : 메모리에 적재되어 바로 명령을 수행할 수 있는 조건을 만족하는 상태(Ready Queue에 대기중)
- `Blocked(Wait, Sleep)` : CPU를 할당받더라도 당장 명령을 수행하지 못하는 상태 (IO 작업처럼 요청한 이벤트가 바로 수행 결과를 반환하지 않아 다음 명령을 수행하지 못하는 상태)
- `Suspened(Stopped)` : 외부적인 이유로 중기 스케쥴러에 의해 메모리를 빼앗겨 수행이 정지된 상태 (디스크로 swap out된다)
- `New` : 프로세스가 생성중인 상태
- `Terminated` : 프로세스의 수행이 완료된 상태

> Blocked와 Suspended
> 
- `Blocked`는 프로세스가 IO와 같이 처리 시간이 긴 작업을 수행하는 상태이다. Blocked 상태의 프로세스가 작업을 마치면 Ready 상태로 전환된다.
- `Suspeneded`는 CPU 또는 외부(사람, 중기 스케쥴러)에 의해 강제로 정지된 상태이다. 메모리를 빼앗겨 디스크로 swap out된다. 외부에서 resume해줘야 active한 상태가 된다.

> 프로세스의 상태 전이
> 

`New → Ready` : 프로세스가 생성되면 Ready Queue에서 CPU 점유권을 얻기 위해 대기중인 Ready 상태가 된다.

`Ready → Running` : Ready 상태의 프로세스가 CPU 점유권을 얻으면 작업을 수행할 수 있는 Running 상태가 된다.

- `Running → Terminated` : 프로세스의 수행이 끝나 CPU 점유권을 반환할 경우
- `Running → Waiting` : 수행 결과를 바로 반환하지 못하는 작업(IO 또는 공유 데이터)을 수행할 경우
    - Running 상태의 프로세스가 IO 작업을 수행하면 IO Queue에 들어가 Blocked 상태가 된다. (공유 데이터에 접근할 경우 Resource Queue에 들어가 Blocked 상태가 된다)
    - IO 작업을 마치면 IO Controller가 CPU에게 Interrupt를 보내 알린다
    - CPU는 해당 프로세스를 Ready 상태로 변환하고 Ready Queue에 대기시킨다.
- `Running → Ready` : timer interrupt가 발생하여(할당된 시간이 만료되어) CPU 점유권을 반환할 경우

> Queue
> 

Queue는 운영체제 Kenel의 Data 영역에서 자료구조로 구현되어 있다.

> PCB
> 

운영체제가 프로세스를 관리하기 위해 프로세스 마다 유지하는 정보를 담는 구조체이다.

![Untitled](Process,%20T%20b6901/Untitled%201.png)

## 프로세스 문맥 교환

`프로세스의 문맥교환`이란 CPU 점유권이 현재 프로세스에서 다른 프로세스로 넘어가는 과정이다.

1. `CPU 점유권을 빼앗기는 상황` : 현재 시점의 문맥을 기억하기 위해서 해당 프로세스의 PCB에다 CPU의 PC값, 레지스턷 값을 저장한다.
2. `CPU 점유권을 얻는 상황` : 운영체제 커널의 Data 영역에 저장된 프로세스의 PCB에 저장된 PC값과 레지스터값을 CPU에 복원시킨다.

> 시스템콜, 인터럽트가 발생하면 문맥교환이 항상 발생하는가? → NO!
> 

`시스템 콜`이란 프로세스에게 원한이 없는 작업을 운영체제에게 요청하는 것이고, `인터럽트`는 CPU에게 이벤트가 발생했음을 알리는 수단이다.

- 시스템 콜이나 인터럽트가 발생하면 CPU 제어권이 프로세스에서 운영체제 커널로 넘어간다. (유저모드의 사용자 프로세스가 커널 모드로 전환된다 해서 문맥교환이 일어나지 않는다)
    1. `사용자 프로세스 A → 운영체제 커널 모드 → 사용자 프로세스 A` 
        
        사용자 프로세스 A가 CPU 점유권을 가지고 있을 때, 시스템 콜이나 인터럽트가 발생하여 운영체제 커널 모드로 수행되다가 CPU 점유권을 유지한 채 사용자 프로세스 A로 돌아오면 문맥 교환이 일어나지 않는다.
        
    2. `사용자 프로세스 A → 운영체제 커널 모드 → 사용자 프로세스 B`
        
        문맥 교환이 일어난다
        

## 스케쥴러

`스케쥴러`란 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드를 지칭한다.

1. `장기 스케쥴러 (Job 스케쥴러)` : 메모리 및 각종 자원을 할당해 줄 프로세스를 선택한다.
    - new 상태의 프로세스들 중 메모리를 할당해줄 프로세스를 선택한다.
    - 시분할 시스템에서는 new 상태의 프로세스가 곧바로 ready 상태가 되기 떄문에 장기 스케쥴러를 이용하지 않는다.
2. `단기 스케쥴러 (CPU 스케쥴러)` : CPU 점유권을 할당해 줄 프로세스를 선택한다.
3. `중기 스케쥴러 (Swapper)` : 메모리를 빼앗아 디스크로 Swap Out할 프로세스를 선택한다
    - 중기 스케쥴러에 의해 메모리를 빼앗긴 프로세스는 Suspended 상태가 된다.
    - `degree of multiprogramming` 을 제어한다. (메모리에 동시에 올라갈 프로세스의 수를 제어)

## 스레드

`스레드`란 프로세스가 할당받은 자원을 이용하는 실행 단위이다.

- `스레드마다 별도의 PC값, 레지스터 값을 가진다` → 독립적인 CPU 수행을 위해서
- `스레드마다 stack이 별도로 존재한다` → 함수 호출이 일어나면 stack 영역에 함수 관련 정보를 쌓는다. (독립적인 작업을 수행하기 위해서)
- `하나의 프로세스 속 모든 스레드는 code, data 영역과 OS 자원을 공유한다`

![Untitled](Process,%20T%20b6901/Untitled%202.png)

## 멀티 프로세스 & 멀티 스레드

### `멀티 프로세스`

하나의 프로그램을 여러 개의 프로세스로 구성하여 프로세스가 병렬적으로 작업을 수행하는 것이다.

- 프로세스간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야할 때 사용한다.

> 장점
> 
1. `안정성` : 프로세스마다 독립된 주소 공간을 가지기 때문에 하나의 프로세스에 문제가 발생해도 다른 프로세스에 영향을 주지 않는다.

> 단점
> 
1. `오버헤드` : 프로세스끼리 독립된 주소공간을 갖기 때문에 문맥교환이 자주 일어난다.
2. `프로세스간의 통신 방식이 따로 필요하다` : 프로세스 간의 통신이 원칙적으로 제한되어 있기 때문에 `IPC(inter process communication)` 방식으로 별도의 통신을 수행한다.
    - 메시지 큐, 공유 메모리, 파이프, 시그널 등

### `멀티 스레드`

하나의 프로세스에 여러 스레드로 병렬 작업을 수행하는 것이다

> 장점
> 
1. `응답성` : 하나의 스레드가 blocked되어도 같은 프로세스 내의 다른 스레드가 running 상태로 실행되어서 빠른 처리가 가능하다
    - 멀티 프로세스 환경에서는 CPU 점유권을 갖고 있다가 blocked되면 해당 프로세스가 수행중인 작업이 지연된다.
2. `자원 공유` : 여러 스레드가 하나의 프로세스의 code, data와 OS 자원을 공유하기 때문에 효율적인 자원 활용 및 통신이 자유롭다 (대신 동기화 문제가 발생할 수 있음)
3. `경제성` : 스레드간의 문맥교환이 프로세스간의 문맥교환보다 오버헤드가 적다 (캐시 메모리를 초기화할 필요도 없고 stack 영역만 문맥교환하면 되기 떄문)

> 단점
> 
1. `동기화 문제` : 하나의 자원을 공유하기 때문에 병목현상이나 데드락과 같은 동기화 문제가 발생할 수 있다. (Locking 기법으로 이를 해결, 뮤텍스, 세마포어)
2. `불안정` : 하나의 스레드에 오류가 발생하면 나머지 스레드에 영향을 미친다.

### `크롬 브라우저`

크롬 브라우저는 멀티 스레드, 멀티 프로세스 환경이다.

1. `멀티 프로세스` : 각각의 탭들은 프로세스로 구성한다. 따라서 하나의 탭에 오류가 발생하여도 다른 탭들에 영향을 미치지 않는다.
2. `멀티 스레드` : 하나의 탭은 멀티 스레드로 구성한다. 파일을 다운로드 하면서 웹 서핑을 할 수 있다.

## IPC

`IPC(Inter Process Communication)`이란 프로세스간에 통신 매커니즘이다.

1. `Message Passing`: 프로세스간에 공유 데이터를 사용하지 않고 커널을 통해 메시지를 주고 받으면서 통신하는 방식이다.
    - Direct Communication : 통신하려는 프로세스 이름을 명시적으로 표시하여 전달하는 방식
    - Indirect Communication : mailbox나 port를 통해 메시지를 간접적으로 전달하는 방식 (mailbox에 있는 메시지를 임의의 프로세스가 꺼내어 확인할 수 있다. 특정 프로세스에게 메시지를 전달할 수 없는 방식)
2. `Shared Memory` : 서로 다른 프로세스들이 일부 주소 공간을 공유하여 통신하는 방식
    - 프로세스는 원칙적으로 자신의 독립적인 주소 공간만 볼 수 있지만 Kernel에게 요청하여 Shared Memory를 할당받아 해당 주소 공간을 공유할 수 있다.
    - 프로세스간 동기화 문제를 스스로 책임져야 한다 (OS가 책임지지 않는다는 의미?)
